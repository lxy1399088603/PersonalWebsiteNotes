## java的内存区域（运行时数据区）
----
&emsp;&emsp;运行时数据区分为堆（heap）、方法区（method area）、程序计数器（pc ）、虚拟机栈（VM strack）、本地方法栈（native stack）;

&emsp;&emsp;程序计数器、虚拟机栈和本地方法栈是线程私有的三块内存区域，生命周期同线程的创建而创建，线程的销毁而销毁；堆和方法区是线程共有的内存区域，在JVM启动时创建；

##### 1、程序计数器
&emsp;&emsp;pc是占内存区域最小的一块内存，但是速度是最快的，他用于记录线程运行位置，因为java中线程是以抢占式调度方式进行调度的，cpu给每一个线程分配时间片，当时间片结束后就会进行资源的争夺，当某线程在时间片结束时还未执行完任务那么pc将会记录下线程的执行位置，当下一次该线程获取资源继续执行的时候可以通过pc快速还原执行场景然后继续执行未执行的字节码指令；在解释阶段，字节码解释器会通过pc去获取下一条要执行的字节码指令；


##### 2、虚拟机栈
&emsp;&emsp;虚拟机栈是用于存储线程内调用方法的栈帧的，每个栈帧中都存在局部变量表、操作数栈、动态链接、方法出口等信息；虚拟机栈和数据结构中的栈理念是相同的，当我们调用方法时就会把对应的栈帧压入虚拟机栈中，当调用结束后就从栈中弹出；

&emsp;&emsp;因为vmStack中存放的是一个一个的栈帧，栈帧是由线程调用方法时产生的；每一个栈帧中都有局部变量表、操作数栈、动态连接、方法返回地址等信息；每个方法的调用和返回都对应着vm上的进栈和出栈操作；

+ **局部变量表**中存放着方法参数和方法内定义的局部变量，以槽为单位，可存放基本的数据类型还有对象的引用类型；
+ **操作数栈**是线程中很重要的一个部分，在方法调用的过程中字节码指令会向操作数栈中写入或提取内容；每个栈帧中的局部变量表会有一个共享部分与虚拟机栈中对的下一个栈帧的操作数栈存放在一起用于共享数据；
+ **动态连接**是用于指向常量池中对的符号引用的，常量池中的符号引用会在类加载或者第一次使用时被转换为直接引用；
+ **方法返回地址**通过方法返回地址可以将方法中的返回值传递给上传调用者，压入操作数栈中并有程序计数器指向方法调用的下一条指令；

##### 3、本地方法栈
&emsp;&emsp;本地方法栈就是本地方法的虚拟机栈；其中的栈帧都是JNI中的方法；

##### 4、堆
&emsp;&emsp;堆是java内存区域最大的一块内存，堆唯一的目的为对象和数组分配空间且存放对象以及数组；堆为每个线程都提供了线程本地分配缓冲区（TLAB）用于提升对象分配时的效率；垃圾回收机制主要的区域是堆；

##### 5、方法区
&emsp;&emsp;方法区是堆的一部分，用于存放被虚拟机加载的类的各种类型信息，例如常量，静态变量，及时编译器便于以后的代码缓存等数据，最重要的是常量池就是存放在堆中的；

##### 6、常量池
&emsp;&emsp;常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外还有常量池表，用于存放编译期生成的各种字面量与符号引用，这部分将在类加载后放到方法区的常量池中；

##### 7、两种异常
StackOverflowError栈深度溢出：当线程请求的栈深度大于虚拟机所允许的深度时；
OutOfMemoryError扩展失败：当栈或堆可以动态扩展，在请求扩展时未能申请到足够的内存；